from struct import *
import os
import random

# by cursor AI 讲解：
# 这个脚本的核心是利用格密码学解决线性方程组：
# 问题：enc = A × flag + k (mod M)
# 约束：flag 是小值向量，k 也是小值向量
# 方法：构造特殊格，使用 CVP 算法求解
# 结果：找到满足约束的 flag 和 k
# 这是一个非常巧妙的密码学攻击方法！

# 运行
# https://cocalc.com/


def Babai_CVP(Lattice, target):
    M = Lattice.LLL()
    G = M.gram_schmidt()[0]
    diff = target
    for i in reversed(range(M.nrows())):
        diff -=  M[i] * ((diff * G[i]) / (G[i] * G[i])).round()
    return target - diff


k = 64
M = 2^64


c = [ 13244763658160674624, 16984722715248776010, 13823152552092075312, 8872005027729308317, 944658967791699030, 4762164768113502609, 7970508862443252836, 12160272659281590635, 6039957581767845842, 13387399675671860304, 223457625040646381, 7400020938306395985, 13006815947764339661, 14974790137618998791, 1677051111356981689, 14826908347697242003, 4100307315139839248, 11667313162750835032, 17884451662841181209, 700760169072551845, 9763295197450104076, 13820477747461557855, 3788699501860632978, 5662505208535483457, 1883355561987039719, 12612643505764470487, 16652632135078143782, 5711900823325907775, 788816540638973573, 887526078719643329, 5907743825921460766, 8909305678501630345, 2274713462250311935, 9677470753652111235, 1151647945440458884, 7622578006388424471, 15758738039487109829, 2341165009861709242, 12099588408092757723, 4071849134272090660, 5721496069837177677, 13074395344070316491, 3637587738492920070, 16899936481413734939, 17070996347950553773, 10567516345120128085, 17644887802610394938, 17735381490861007130, 14385886897255495713, 7639831089182107678, 6994070516149443833, 17502433187160077562, 15560352708580736915, 2662404873876617361, 11290019096924517203, 5134458835455614050, 8750122284432223604, 7285361309028209651, 142275419733755324, 7707013106987804035, 7581832701782391777, 4445868918336293611, 14577053136653844186, 11537874068167147901 ]
n = 23
while True:

    # A
    a = []
    random.seed(int(0))
    for i in range(64):
        v = []
        for j in range(n):
            v.append(random.randrange(0,2**64))
        a.append(v)

    A = matrix(k,n)

    for i in range(k):
        for j in range(n):
            A[i, j] = a[i][j]
    #B
    # 构造特殊格式的格矩阵：
    # B = [M*I_k    A]
    #     [0        I_n]
    # M*I_k: 64×64 对角矩阵，对角线为 M
    # A: 64×n 矩阵
    # 0: n×64 零矩阵
    # I_n: n×n 单位矩阵

    B = matrix(n+k,n+k)

    for i in range(k):
        B[i,i] = M

    for i in range(k):
        for j in range(n):
            B[i,k+j] = A[i][j]

    for i in range(k, n+k):
        B[i,i] = 1

    # 构造目标向量
    t = vector(ZZ, [0]*(n+k))

    for i in range(k):
        t[i] = c[i]
    print('[-]'+'the flag length is: '+ str(n))
    P = Babai_CVP(B.transpose(),t)
    
    print(P[k:])
    flag = "".join(chr(c) for c in P[k:])
    print('[+]'+flag)
    n+=1
    if 'flag' in flag:
        break
